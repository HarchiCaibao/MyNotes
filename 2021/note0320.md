# 1、计算机网络
     https://zhuanlan.zhihu.com/p/84316213
## TCP/IP五层模型
     应用层
        定义了应用进程之间的通信和交互的规则，不同的应用程序需要不同的应用层协议，如域名解析的DNS协议，web应用
        的http协议。该层的数据称为报文。
     运输层
        为两台主机进程之间提供通用的数据传输服务。具有复用和分用的特点。 典型协议是TCP,UDP协议
     网络层
        为数据传输选择合适的路径（网间路由和交换节点），网络层会把运输层的数据报文封装成分组和包进行传输。典型协议是IP协议。
     数据链路层
     
     物理层

## http & https
     超文本传输协议，是应用层定义的web应用之间通信和交互的规则协议。
     https 其实就是http协议，但是https在http协议的基础上，增加了SSL协议。一次https的建立过程为：
     1、客户端端向服务端申请数据访问，服务端收到后，已数据证书的形式返回服务端的公钥，证书颁发机构等信息。
     2、客户端向权限的证书机构验证收到数据证书的合法性。如果合法，客户端会生成一个对称加密的算法和与之对应的
        随机密钥，并使用第一步获得的服务端公钥进行加密。然后发给服务端。
     3、服务端使用私钥解密出客户端的随机密钥和对称加密算法。支持一个https连接建立，在之后的通信中，客户端与
        服务端通过建立连接时生成的随机密钥对数据进行对称加密后进行传输。  
## tcp协议
     tcp协议是传输层的一个协议，为应用层的数据传输提供了通用的服务。tcp协议是面向连接的，可靠的，基于字节流的传输层协议。
     常见对应的应用层协议是http，ftp
### tcp的主要特点
     1、面向连接，即进行数据传输之前，需要建立好两端的连接，如打电话，需要先拨号打通。
     2、数据传输时点对点的。
     3、数据传输时可靠的。
     4、提供全双工通信，允许进程在任意时刻都能发送数据
     5、面向字节流的，即虽然应用层交付下来的数据一个大小不等的数据报文，但tcp时把这些数据看做一连串的字节流   
### tcp 如何保证可靠传输
     https://blog.csdn.net/cbjcry/article/details/84925028
     1、可以对数据包进行校验，若数据包出错，则会丢弃，并不给予响应。至于如果判断数据是否出错：使用校验和的方式
        对发送的数据二进制相加后取反，校验结果是否等于1.
     2、超时重传。维护一个定时器，在指定时间内，未收到ack则进行重传。
     3、丢弃重复数据。
     4、对失序的数据进行重排序。
     5、流量控制。两端都有一个缓冲区，接收端只允许发送端发送接收端缓冲区能容纳的数据，当接收端来不及处理时，会提示
        发送端降低发送速率。通过接收端维护一个可变大小的滑动窗口实现。
     6、拥塞控制。 当识别到网络拥堵时，可以减小数据的发送。通过发送端为一个拥塞窗口来实现。 
### 接收端滑动窗口的实现原理
     tcp协议的报头中，有16位的字段记录了窗口的大小。接收端在ack报文时，会带上剩余窗口的大小，当发送端发现剩余窗口
     大小为0时，会停止数据的发送。并定时地向接收端发送窗口大小探测数据，及时获取缓冲区的大小。

### 发送端的拥塞控制原理
     1、慢启动，由于发送端无法预知当前网络的情况，故发送会先发送少量数据，以探明当前的网络情况。每次收到ack时，拥塞窗口会加一。
     2、拥塞避免，拥塞窗口的增长是指数级别的，即增长数据非常快。此时为了避免增长过快导致的网络堵塞。当拥塞窗口大小达到某个阈值时，
        拥塞窗口的增加改为线性增长。
     3、拥塞发生，当出现超时重传现象时，拥塞窗口的阈值会减小到之前阈值的一半。
     4、快速恢复：当接收端收到乱序的数据段时，会立即ack一次发送端，若发送端收到该ack三次，会立即重传这些数据段。   
### tcp 粘包

## udp
     udp协议也是传输层的一个协议，是无连接的，其不保证数据的可靠交付。常见的应用层协议是：DNS协议
### udp的特点
     1、无连接的
     2、不保证数据的可靠交付。
     3、支持一对一，一对多，多对多，多对一的通信。
     4、无拥塞控制，网络阻塞是不会影响数据的发送速率。     
## ip协议
    ip协议是网络层的一个协议，其作用是选择合适的路径传输数据报文到指定的主机。
## http vs rpc

# 2、数据库
## 事务
     指的是满足ACID特性的一组操作。
          A 原子性：事务为最小的执行单元，不可分割，要么都成功，要么都失败。
          C 一致性：在事务前后数据保持一致性，所有事务读取的同一数据都是一致的
          I 隔离性：事务提交前，对其他事务不可见
          D 持久性：事务提交后，其修改需永久保存在数据库中。
     开始事务：begin，提交事务：commit
## 并发一致性
     脏读：读到了另一个事务修改了但未提交的数据
     不可重复读：一个事务，多次读取同一数据，出现了数据不一致的情况，读到了其他事务提交的数据
     幻读：多次读取一个范围内的数据时，出现了结果不一致的情况
## 封锁

## 隔离级别
     通过隔离级别，可以避免出现的并发一致性问题。
          读未提交：无法避免任何的并发一致性问题
          读已提交：可以避免脏读问题，不可以解决不可重复读和幻读问题
          可重复读：解决脏读，不可重复读的问题，不可解决幻读问题。为mysql的默认隔离级别
          序列化：  解决所有的并发一致性问题。
     查询隔离级别： select @@tx_isolation.
## 多版本并发控制(MVCC)
     是实现读已提交和可重复读的一种具体方式。
     MVCC通过在每行数据增加两个隐藏的列来实现的，一列记录行的新增系统版本号，一列记录行的删除系统版本号。
     每开始一个事务，系统版本号自动加一，且该版本号用做事务的版本号，用于查询时的版本号对比使用。在可重复
     读的隔离级别下，对于crud，mvcc的执行流程时：
     SELECT
          根据以下两个条件检查符合查询条件的每行记录；
               1、行的插入版本号，要么小于当前的事务版本号，要么等于当前的事务版本号。这样可以保证查询到
          的数据，要么是在事务开始之前就存在的，要么是本次事务修改的数据。
               2、行的删除版本号，要么不存在，要么大于当前的事务版本号，这样可以保证数据在事务开始之前未被删除。
     INSERT:
          行的插入版本号为当前的系统版本号
     DELETE:
          行的删除版本号，为当前的系统版本号
     UPDATE：
          update的时候，会插入一条新的记录，行的插入版本号，为当前的系统版本号，且将原数据的行删除版本号，置为当
          前的系统版本号。          
     举一个可重复读出现的幻读的例子。 https://blog.csdn.net/w139074301/article/details/111052454
     从上面的MVCC的crud流程可以模拟：
     启动两个事务，T1,T2。
     T1 select 出表的所有记录。此时假设有一条记录。
     T2 此时新增一条记录。
     T1 在T2执行完新增后，再次执行查询，此时由于读取的版本号对比规则，只会查出一条记录，满足可重复读。刚好也会让人误以为会
     满足避免了幻读。
     T2提交事务，
     T1 执行一个update语句，该语句update 表中的所有数据。此时，由于update的执行逻辑，会出现T2新增的那条记录，出现一行是
     行删除版本为T1事务版本号的记录，还有一行是行的新增版本号为T1事务的版本号的记录。
     T1再次执行查询，会查出两条记录，其中一条是T2新增的，但是T1修改过的数据。出现了幻读。
## 乐观锁
     读不阻塞，写阻塞。
     实现：通过一个version字段，可以实现。
     如：update tbl set amount = amount + 100 where id = 1 and version = 1;
     但是这种在一些业务场景下时不适用的，可能会造成用户体验问题，如秒杀时的库存修改，如果使用version这种方式加乐观锁，可
     能会造成大量的失败。优化：使用库存来实现乐观锁，update tbl set kucun = kucun -1 where id = xxx and kucun - 1 > 0;
## 悲观锁
     读写均阻塞。
     实现：select * from tbl for update.
## 索引
   .微信：MySQL 的索引.  https://mp.weixin.qq.com/s/JZibpKHOBlH_fFah5JABRw
   ### 索引是什么
     索引是一种用于快速检索数据的一种数据结构。已InnoDB引擎为例来讲解myql的索引，InnoDB的最小存储单位是页，每行数据按该
   行的主键的大小顺序，已单链表的形式存储在每一页中，一页数据大小默认是16K.数据页之间是一个双向链表。在没有索引的情况下，如果
   我们需要根据主键来检索一条数据，则需要从该表数据的根页开始，顺序的每一页已二分法的方式查找符合条件的数据，直至找到记录为止。
   显然这种查找方式很慢。如果能在查找时，直接就能知道待查找的数据所在的页数，那效率可以大大提高，而mysql索引就是就是实现了
   这个目的。我大致把mysql索引划分为主键索引和辅助索引（二级索引）
   ### 索引的结构
     我们已主键索引为例，阐述索引的结构。既然索引可以快速定位数据所在的页，那么这个映射关系必然需要记录，我们把记录这个映射
   关系的数据成为目录项，目录项大概由目录项标志位，主键和已该主键为第一条记录存储的页数值，目录项内部按主键的大小排序，构成一个
   单链表。目录项单独存储在页中，不与表数据混合存在一页中。当我们使用主键查找一条数据时，会先到目录项所在的页，通过二分查找法定
   位到数据所在的页，然后到该数据记录页已二分查找的方式，定位到相应的数据，至此一次以主键查询的操作完成。
     以上的数据结构，如果我们根据功能来已层划分，可以将存储了用户完整记录的数据页都归到一层，将目录项的数据页归到另一层，可以
   得出，这是种多叉的树形结构，其中目录项的页为根节点，数据项的页页为叶子节点。当然目录项也是存储在页中，一页最大是16K，所以数据
   多的时候，目录项是不止一页，此时我们只需要把多页的目录项假想为数据记录项，我们再为这些假的数据记录项，分配新的一页作为目录项，
   独立作为一层，记录下一层的目录项的页数信息。由于mysql索引的这种存储结构，跟B+数的结构是完全一致的，故采用B+数作为索引的数据
   结构最为合适。     
   ### 聚簇索引
     1、索引中的数据按主键大小顺序排列。
     2、数据项页中存储了行数据的所有列。
   ### 辅助索引
     InnoDB中，辅助索引的数据库结构和主键索引是一样的，不同的地方是数据项记录页记录的数据不同。辅助所以的数据项记录，只会存储
   该索引的列值和对应的主键值。
     因此，通过辅助索引查询记录时，如果查询的列不仅仅包含该索引的列时，会执行两次索引的遍历操作，第一次现在辅助索引里找到对应的
   主键，然后遍历主键索引，获得对应的数据。因此。这里可以延申出一个查询优化问题，使用辅助索引查询数据，且只需要使用索引列的数据，
   则需要指定select的列，而不是简单的select *.
   ### 索引为什么使用B+树而不是其他树
     索引使用B+树实现，数据存放在B+树的叶子节点中，B+树的非叶子节点存放键值+指针数据。当在B+树进行数据检索时，先在非
   叶子节点进行二分查找，确定数据所在的页，然后在该页查询符合条件的数据返回。
   B树的所有节点都有可能保存数据，导致非叶子节点保存的指针数据变少，若保存大量的数据，会增加树的高度，IO增加. 
   ### select * from tbl where id = x 的主键索引执行流程
     在InnoDB存储引擎前提下，二分查找的方式遍历主键索引的目录项页，找到该主键对应的数据所在的页，最后到该页，通过二分查找法获得
     相应的数据。
     在MyISAM存储引擎的前提下，先根据主键索引，找到，该数据的行号，最后根据行号获得数据返回。
   ### select * from tbl where uinon_key  = x 的索引执行流程。（uinio_key 为普通索引）
     由于使用辅助索引，且select *。 会先二分查找遍历辅助索引的目录项，找到该查询条件所在数据页，然后在该数据页二分查找到对应记
   录的主键，最后遍历主键索引，返回数据集。但如果sql改成  select uinon_key from XXXX,则只需要遍历一次辅助1索引即可获得数据。
   ### 主键自增id与雪花id
     从mysql的索引和数据的存储结构来看，当主键是雪花id时，会出现数据页存在不饱和的情况，产生碎片。

# 技能
## kong

## springBoot

## Java

## PHP

## clickHouse


   
