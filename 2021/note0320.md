# 计算机网络
     https://zhuanlan.zhihu.com/p/84316213
## TCP/IP五层模型
     应用层
        定义了应用进程之间的通信和交互的规则，不同的应用程序需要不同的应用层协议，如域名解析的DNS协议，web应用
        的http协议。该层的数据称为报文。
     运输层
        为两台主机进程之间提供通用的数据传输服务。具有复用和分用的特点。 典型协议是TCP,UDP协议
     网络层
        为数据传输选择合适的路径（网间路由和交换节点），网络层会把运输层的数据报文封装成分组和包进行传输。典型协议是IP协议。
     数据链路层
     
     物理层

## http & https
#### http

超文本传输协议，是应用层定义的web应用之间通信和交互的规则协议。

#### https

##### 流程

 https 其实就是http协议，但在http协议的基础上，增加了SSL协议。一次https（单向认证）的建立过程为：
 1、客户端生成一个随机数R1,带上自己支持的加密算法，发送给服务端。
 2、服务端收到建立连接请求后，随机选择客户端支持的一种加密算法，并生成一个随机数R2，然后把这些数据跟服务端的SSL证书一起发送给客户端,这个证书里面包含了：公钥，签名，颁发机构CA(数字证书认证机构)，过期时间，证书持有者等信息。
 3、客户端收到证书后，首先需要验证证书似乎否真的来自自己请求的服务端。客户端会用内置受信任的CA机构与服务端的证书CA进行比对，校验证书是否为合法的CA机构颁发。如果合法，则使用颁发者的CA公钥解密签名信息，然后对服务端证书进行签名，并将计算得到得签名值与服务端发来的签名值比对，如果一致，则认为证书安全，未被篡改。
 4、验证服务端证书合法性后，客户端会生成一个随机数R3,并将R3使用服务端公钥加密后发给服务端。
 5、服务端使用私钥解密，得到R3，使用R1,R2,R3生成通信用的对称加密密钥。
 6、此后的两端通信，数据均通过对称加密的密钥进行加密和解密。

##### 如何验证服务端证书的合法性

1、对证书持有者，生效时间进行校验。

2、查看证书的发布机构是否在内置已信任的证书颁发机构中，如果不在则弹出报错信息。

3、客户端找到匹配的颁发机构CA后，会使用内置的CA公钥解密服务端证书的签名。然后使用相同的hash算法，对服务端的正式就是一次hash，并将这个hash值与解密的服务端证书签名作比较，如果一致，则证明证书没有被篡改，证书合法。

#### 一次网站的访问流程

![网站访问流程](E:\work\note\MyNotes\2021\网站访问流程.png)

## tcp协议
     tcp协议是传输层的一个协议，为应用层的数据传输提供了通用的服务。tcp协议是面向连接的，可靠的，基于字节流的传输层协议。
     常见对应的应用层协议是http，ftp
### tcp的主要特点
     1、面向连接，即进行数据传输之前，需要建立好两端的连接，如打电话，需要先拨号打通。
     2、数据传输时点对点的。
     3、数据传输时可靠的。
     4、提供全双工通信，允许进程在任意时刻都能发送数据
     5、面向字节流的，即虽然应用层交付下来的数据一个大小不等的数据报文，但tcp时把这些数据看做一连串的字节流   
### tcp 如何保证可靠传输
     https://blog.csdn.net/cbjcry/article/details/84925028
     1、可以对数据包进行校验，若数据包出错，则会丢弃，并不给予响应。至于如果判断数据是否出错：使用校验和的方式
        对发送的数据二进制相加后取反，校验结果是否等于1.
     2、超时重传。维护一个定时器，在指定时间内，未收到ack则进行重传。
     3、丢弃重复数据。
     4、对失序的数据进行重排序。
     5、流量控制。两端都有一个缓冲区，接收端只允许发送端发送接收端缓冲区能容纳的数据，当接收端来不及处理时，会提示发送端降低发送速率。通过接收端维护一个可变大小的滑动窗口实现。
     6、拥塞控制。 当识别到网络拥堵时，可以减小数据的发送。通过发送端为一个拥塞窗口来实现。 
### 接收端滑动窗口的实现原理
     tcp协议的报头中，有16位的字段记录了窗口的大小。接收端在ack报文时，会带上剩余窗口的大小，当发送端发现剩余窗口大小为0时，会停止数据的发送。并定时地向接收端发送窗口大小探测数据，及时获取缓冲区的大小。

### 发送端的拥塞控制原理
     1、慢启动，由于发送端无法预知当前网络的情况，故发送会先发送少量数据，以探明当前的网络情况。每次收到ack时，拥塞窗口会加一。
     2、拥塞避免，拥塞窗口的增长是指数级别的，即增长数据非常快。此时为了避免增长过快导致的网络堵塞。当拥塞窗口大小达到某个阈值时，
        拥塞窗口的增加改为线性增长。
     3、拥塞发生，当出现超时重传现象时，拥塞窗口的阈值会减小到之前阈值的一半。
     4、快速恢复：当接收端收到乱序的数据段时，会立即ack一次发送端，若发送端收到该ack三次，会立即重传这些数据段。   
### tcp 粘包/拆包

​	tcp是面向流的，对数据包没有边界。

​	解决方法：

​		1、消息定长

​		2、增加结束标志

## udp
     udp协议也是传输层的一个协议，是无连接的，其不保证数据的可靠交付。常见的应用层协议是：DNS协议
### udp的特点
     1、无连接的
     2、不保证数据的可靠交付。
     3、支持一对一，一对多，多对多，多对一的通信。
     4、无拥塞控制，网络阻塞是不会影响数据的发送速率。     
## ip协议
    ip协议是网络层的一个协议，其作用是选择合适的路径传输数据报文到指定的主机。
## http vs rpc

# 数据库
## 事务
     指的是满足ACID特性的一组操作。
          A 原子性：事务为最小的执行单元，不可分割，要么都成功，要么都失败。
          C 一致性：在事务前后数据保持一致性，所有事务读取的同一数据都是一致的
          I 隔离性：事务提交前，对其他事务不可见
          D 持久性：事务提交后，其修改需永久保存在数据库中。
     开始事务：begin，提交事务：commit
## 并发一致性
     脏读：读到了另一个事务修改了但未提交的数据
     不可重复读：一个事务，多次读取同一数据，出现了数据不一致的情况，读到了其他事务提交的数据
     幻读：多次读取一个范围内的数据时，出现了结果不一致的情况
## 封锁

## 隔离级别
     通过隔离级别，可以避免出现的并发一致性问题。
          读未提交：无法避免任何的并发一致性问题
          读已提交：可以避免脏读问题，不可以解决不可重复读和幻读问题
          可重复读：解决脏读，不可重复读的问题，不可解决幻读问题。为mysql的默认隔离级别
          序列化：  解决所有的并发一致性问题。
     查询隔离级别： select @@tx_isolation.
## 多版本并发控制(MVCC)
     MVCC是实现读已提交和可重复读的一种具体方式。
     MVCC通过在每行数据增加两个隐藏的列来实现的，一列记录行的新增系统版本号，一列记录行的删除系统版本号。
     每开始一个事务，系统版本号自动加一，且该版本号用做事务的版本号，用于查询时的版本号对比使用。在可重复
     读的隔离级别下，对于crud，mvcc的执行流程时：
     SELECT
       根据以下两个条件检查符合查询条件的每行记录；
         1、行的插入版本号，要么小于当前的事务版本号，要么等于当前的事务版本号。这样可以保证查询到的数据，要么    是在事务开始之前就存在的，要么是本次事务修改的数据。
         2、行的删除版本号，要么不存在，要么大于当前的事务版本号，这样可以保证数据在事务开始之前未被删除。
     INSERT:
         行的插入版本号为当前的系统版本号
     DELETE:
         行的删除版本号，为当前的系统版本号
     UPDATE：
         update的时候，会插入一条新的记录，行的插入版本号，为当前的系统版本号，且将原数据的行删除版本号，置为当前的系统版本号。 
## 举一个可重复读出现的幻读的例子 

 https://blog.csdn.net/w139074301/article/details/111052454
 从上面的MVCC的crud流程可以模拟：
 启动两个事务，T1,T2。
 （1）T1 select 出表的所有记录。此时假设有一条记录。
 （2）T2 此时新增一条记录。
 （3）T1 在T2执行完新增后，再次执行查询，此时由于读取的版本号对比规则，只会查出一条记录，满足可重复读。刚好也会让人误以为会满足避免了幻读。
 （4）T2提交事务，
 （5）T1 执行一个update语句，该语句update 表中的所有数据。此时，由于update的执行逻辑，会出现T2新增的那条记录，出现一行是行删除版本为T1事务版本号的记录，还有一行是行的新增版本号为T1事务的版本号的记录。
 （6）T1再次执行查询，会查出两条记录，其中一条是T2新增的，但是T1修改过的数据。出现了幻读。

## 乐观锁

     读不阻塞，写阻塞。
     实现：通过一个version字段，可以实现。
     如：update tbl set amount = amount + 100 where id = 1 and version = 1;
     但是这种在一些业务场景下时不适用的，可能会造成用户体验问题，如秒杀时的库存修改，如果使用version这种方式加乐观锁，可能会造成大量的失败。
     优化：使用库存来实现乐观锁，update tbl set kucun = kucun -1 where id = xxx and kucun - 1 > 0;
## 悲观锁
     读写均阻塞。
     实现：select * from tbl for update.
## 索引
   .微信：MySQL 的索引.  https://mp.weixin.qq.com/s/JZibpKHOBlH_fFah5JABRw
   ### 索引是什么
     索引是一种用于快速检索数据的一种数据结构。已InnoDB引擎为例来讲解myql的索引，InnoDB的最小存储单位是页，每行数据按该行的主键的大小顺序，已单链表的形式存储在每一页中，一页数据大小默认是16K.数据页之间是一个双向链表。在没有索引的情况下，如果我们需要根据主键来检索一条数据，则需要从该表数据的根页开始，顺序的每一页已二分法的方式查找符合条件的数据，直至找到记录为止。显然这种查找方式很慢。如果能在查找时，直接就能知道待查找的数据所在的页数，那效率可以大大提高，而mysql索引就是就是实现了这个目的。我大致把mysql索引划分为主键索引和辅助索引（二级索引）
   ### 索引的结构
     我们已主键索引为例，阐述索引的结构。既然索引可以快速定位数据所在的页，那么这个映射关系必然需要记录，我们把记录这个映射关系的数据成为目录项，目录项大概由目录项标志位，主键和已该主键为第一条记录存储的页数值，目录项内部按主键的大小排序，构成一个单链表。目录项单独存储在页中，不与表数据混合存在一页中。当我们使用主键查找一条数据时，会先到目录项所在的页，通过二分查找法定位到数据所在的页，然后到该数据记录页已二分查找的方式，定位到相应的数据，至此一次以主键查询的操作完成。
     以上的数据结构，如果我们根据功能来已层划分，可以将存储了用户完整记录的数据页都归到一层，将目录项的数据页归到另一层，可以得出，这是种多叉的树形结构，其中目录项的页为根节点，数据项的页页为叶子节点。当然目录项也是存储在页中，一页最大是16K，所以数据多的时候，目录项是不止一页，此时我们只需要把多页的目录项假想为数据记录项，我们再为这些假的数据记录项，分配新的一页作为目录项，独立作为一层，记录下一层的目录项的页数信息。由于mysql索引的这种存储结构，跟B+数的结构是完全一致的，故采用B+数作为索引的数据结构最为合适。  
![网站访问流程](E:\work\note\MyNotes\2021\主键索引的结构.jpg)

   ### 聚簇索引

     1、索引中的数据按主键大小顺序排列。
     2、数据项页中存储了行数据的所有列。
   ### 辅助索引
     InnoDB中，辅助索引的数据库结构和主键索引是一样的，不同的地方是数据项记录页记录的数据不同。辅助索引的数据项记录，只会存储该索引的列值和对应的主键值。因此，通过辅助索引查询记录时，如果查询的列不仅仅包含该索引的列时，会执行两次索引的遍历操作，第一次现在辅助索引里找到对应的主键，然后遍历主键索引，获得对应的数据。因此。这里可以延申出一个查询优化问题，使用辅助索引查询数据，且只需要使用索引列的数据，则需要指定select的列，而不是简单的select *.
   ### 索引为什么使用B+树而不是其他树
     索引使用B+树实现，数据存放在B+树的叶子节点中，B+树的非叶子节点存放键值+指针数据。当在B+树进行数据检索时，先在非叶子节点进行二分查找，确定数据所在的页，然后在该页查询符合条件的数据返回。B树的所有节点都有可能保存数据，导致非叶子节点保存的指针数据变少，若保存大量的数据，会增加树的高度，IO增加. 
   ### select * from tbl where id = x 的主键索引执行流程
     在InnoDB存储引擎前提下，二分查找的方式遍历主键索引的目录项页，找到该主键对应的数据所在的页，最后到该页，通过二分查找法获得相应的数据。
     在MyISAM存储引擎的前提下，先根据主键索引，找到该数据的行号，最后根据行号再遍历一遍数据后获得数据返回。
   ### select * from tbl where uinon_key  = x 的索引执行流程。（uinio_key 为普通索引）
     由于使用辅助索引，且select *。 会先二分查找遍历辅助索引的目录项，找到该查询条件所在数据页，然后在该数据页二分查找到对应记录的主键，最后遍历主键索引，返回数据集。但如果sql改成  select uinon_key from XXXX,则只需要遍历一次辅助1索引即可获得数据。
   ### 主键自增id与雪花id
     从mysql的索引和数据的存储结构来看，当主键是雪花id时，会出现数据页存在不饱和的情况，产生碎片。


### 索引失效

https://mp.weixin.qq.com/s/A_-n_05Q4HrF9mtekuTgvg

NULL 值列

NOT IN

前置LIKE 查询





# 缓存redis

## redis 基础



## redis 分布式锁

https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/

### 实现

SETNX 命令：当key不存在时，set成功。

EXPIRE: 设置锁的持有时间。

SETNX操作是非原子多的，可以通过LUA脚本来实现原子操作。

一般，可以使用Redisson 来实现分布式锁，封装好了。

### 锁误解除(锁超时，任务未执行完)

只能解自己的锁，锁加标志。 哨兵，锁超时，任务未完成，延长加锁。

Redis 分布式锁只能作为一种缓解并发的手段，如果要完全解决并发问题，仍需要数据库的防并发手段。







# 技能

## kong



## springBoot

### 自动配置实现原理

从@SpringBootApplication注解进去，可以看到@EnableAutoconfiguration注解，该注解，就是实现自动配置用的。@EnableAutoConfiguration注解，由@AutoConfigurationPackage注解和@Import(AutoConfigurationInportSelector.class)组成，前一个注解主要是扫描主类所在的包和子包的类到Spring容器中。后一个注解import的组件，是扫描META-INF/spring.factories文件里的EableAutoConfig指定的值，这些值是自动配置类的类路径，这个组件会把这些自动配置类扫描加入到Spring容器中，已完成自动配置的实现。

## Java

### Map

#### HashMap线程不安全的表现

在jdk1.7中，主要的，扩容会造成数据丢失或者环形链表（因为扩容采用了头插法，导致死循环）

在jdk1.8中，put操作会出现数据被覆盖的风险。扩容时链表的处理，不再使用头插法，而是直接插入到链表的尾部。

#### HashMap 和HashTable的null值问题



### 多线程

#### 线程池的核心参数

​		corePoolSize：核心线程数大小。当线程池提交一个任务时，如果当前线程数小于corePoolSize，即使当前存在空闲线程，也会新建一个线程来处理该任务。

​		任务队列（workQueue）：用于传输和保存待执行的线程阻塞任务。当核心线程数达到corePoolSize时，会将任务放进队列中。

​	    maxPoolSzie：线程池的最大线程数大小。当任务队列满时，且当前线程数小于maxPoolsize时，会创建新的线程来执行任务。

​	   keepAliveTime: 当线程池中的线程数大于核心线程数时，线程的空闲时间大于keepAliveTime就会被销毁.

​	  拒绝策略（AbortPlocy）：当非空闲线程达到maxPoolSize时，再向线程池提交任务，则会触发该拒绝策略。

​	  线程工厂：生成线程的工程模板类，一般会自定义线程名，便于查找问题.

#### 线程池的任务提交时序图

​	    1、核心线程池已满？未满则新建一个线程，已满则执行2

​		2、任务队列已满？未满则将任务放到队列中，已满则执行3

​		3、最大线程池已满？未满则新建一个线程，已满则执行4

​		4、根据拒绝策略执行任务拒绝处理

![线程池任务执行流程](E:\work\note\MyNotes\2021\线程池任务执行流程.png)

#### 线程的生命周期

创建：当使用new创建一个线程时，线程就会处于新建状态，此时jvm会给该变量分配内存。

就绪：当调用线程的start()方法时，线程进入就绪态，jvm会为其创建方法调用栈和程序计数器。就绪状态表明线程已经可以运行了，但是不一定会立即运行，运行的时机取决与jvm的线程调度器的调度。

ps：如果需要线程立即执行，可以执行Thread.sleep(1)，主线程休眠1毫秒，此时cpu空闲，会立马去执行一个就绪态的线程，达到立马执行的目的.

运行：当线程获得cpu资源时，线程将处于运行态，此时会执行线程里的run方法的具体逻辑。

阻塞：线程执行后，是有可能会切换到阻塞状态的，

死亡:  当线程run方法执行完成；线程执行抛出runtimeexcepion或者error

### JVM

#### Java内存模型

![java虚拟机内存图](E:\work\note\MyNotes\2021\java虚拟机内存图.jpg)

参考：

美团GMC详解：https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651754955&idx=1&sn=8411133d2e5f22b9e2c5a34cdc67985d&chksm=bd1248868a65c1900dd1b7203ce17159740253df2324a208ea9c71ee764e1bde1ed2616d77ce&scene=178&cur_album_id=1603714331009974274#rd

江南白衣：http://www.360doc.com/content/17/1015/14/16915_695113964.shtml

Java8内存主要分为栈，堆和非堆三大块。

##### 栈

由程序计数器，虚拟机栈，本地栈组成。为线程私有，用于存放局部变量，方法出口等信息，会生成StackOverFlowError和OOM。大小由-xss设置

##### 堆

分为新生代，老年代，运行时常量池。为线程共享，是GC发生的主要区域。主要存放对象实例和数组，会发生OOM，大小由-Xms（初始大小），-Xmx（最大大小）设置。

##### 非堆(方法区)

由元空间，本地内存，代码缓存组成，其中元空间也是会发生GC的内存区域.

#### 垃圾回收

垃圾回收发生在堆内存区域非堆的元空间。首先细讲一下堆内存。

##### Java堆（对象分配）

堆分为新生代，老年代，运行时常量池。新生代又分为：eden区，From survivor区和To Survivor区。

对象分配可以使用空闲链表（额外内存记录空闲地址）和碰撞检测（指针指向分界点，对象分配指针移动对象的大小空间）算法来完成。对象的内存分配，往大的方向讲，就是在堆上分配，分配规则不是百分百固定，由垃圾收集器组合和jvm参数设置有关。但是主要的，由以下几点：

1、对象优先在eden区分配.当Eden无内存可分配，出发一个minorGC。

2、大对象直接分配在老年代。有个参数可以设置大小阈值.

3、长期存活的对象进入老年代。

##### 判断对象是否可以被回收

###### 引用计数法

对每个对象的引用进行计数，每当一个地方引用它时，计数器加一，引用失效则计数器减一，引用计数大于0的对象认为时存活对象，引用计数法可以通过Recycler算法或者强弱引用的方法来解决循环引用。但是在并发的情况下，这种性能比较低。

###### 可达性分析算法

从GC Root节点开始遍历，可以搜索到的对象为存活对象，否则判为可回收对象

##### 垃圾回收算法

###### 标记清除算法

第一阶段从GC Root 开始遍历，标记每个遇到的对象，这些对象都是还存活的对象，不能被回收；第二阶段则回收那些未被标记的对象。清除过程中不会移动未被标记的对象，会产生内存碎片。该算法在存活对象多的场景下比较高效

###### 复制算法

将内存分为两个区域，同一时间只会使用其中一块，另一块时空闲的，进行垃圾回收时，会将所有存活的对象复制到空闲的空间，然后对刚使用过的那块内存执行一次全量内存回收。该算法空间利用率不高，复制大对象成本高。但是对于大量生命周期短的对象的场景下比较高效。

###### 标记-整理算法

第一阶段从GC Root 开始遍历，标记每个遇到的对象，这些对象都是还存活的对象，不能被回收。标记完成后，会让被标记的对象向一端移动，最后直接清理掉端外边界以外的内存区域。老年代的对象生命周期长，适合使用该算法进行垃圾收集

一般垃圾收集器会根据内存分代的特点，新生代选用复制算法，老年代选用标记-整理算法，统称分代收集算法。

##### 垃圾收集器

###### ParNew

​	多线程垃圾收集器，主要作用于新生区，采用复制算法，可以通过设置-XX:ParallelGCThreads 来设置垃圾收集的线程数，整个垃圾收集的过程中，用户线程处于挂起状态（Stop The Word）。

###### Serial Old

​	多线程垃圾收集器，作用于老年代，采用标记-整理算法，整个过程Stop The Word。其可作为CMS收集器在运行期间预留的内存无法满足程序需要（Concurrent Mode Failure）时作为备用收集器使用。

###### CMS

​	一款以获得最短垃圾回收停顿时间为目标的多线程垃圾收集器，采用“标记-清除”算法，分为：初始标记，并发标记，重新标记和并发清理四个过程；其中初始标记和重复标记需要Stop The Word，但是这两步耗时很短，而剩余的两个过程是于用户线程并行执行的，耗时较长，所以CMS可以认为是于用户线程一起执行的垃圾收集器。

​	初始标记：执行一次GC Root的遍历，标记能关联到对象。

​	并发标记：进行GC Root追踪过程。

​	重新标记：修正并发标记期间用户线程并发执行造成的变动对象。

​	并发清除：进行垃圾回收。

CMS缺点及优化方案：

​	1：会产生浮动垃圾，即并发标记过程中产生了无法被标记到的垃圾，且垃圾收集过程中，需留内存给用户线程使用，故CMS会在老年代的内存使用了一定阈值后触发，这个阈值默认是68，可以通过设置CMSInitiatingOccupancyFraction来指定，B设置的是75。这个不能设置太大，如果太大，会出现“Concurrent Mode Failure”，此时Serial Old垃圾收集器会作为备用垃圾收集器对老年代执行一次Full GC。

   2: 标记-清除算法会产生内存碎片，CMS默认会开启在顶不住进行FullGC会进行碎片整理，默认开启，且有一个参数（CMSFullGCsBeforeCompaction），可以设置执行多少次Full GC后，执行一次碎片整理，默认是0.

备注：CMS 在JDK9被标记了弃用，在JDK14被删除。

#### jvm参数设置

```
-Xms2048m -Xmx2048m -Xmn1024m: 堆的初始大小，最大大小，新生代大小。
-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m: 元空间初始大小，最大大小
-XX:SurvivorRatio=2: 新生代Eden区于Survivor区大小比例，2:1
-XX:+UseConcMarkSweepGC：使用ParNew+CMS+Serial Old收集器进行垃圾回收。Serial old作为cms出现“Concurrent Mode Failure”后作为老年代垃圾收集器使用
-XX:CMSInitiatingOccupancyFraction=75：设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认是是68%.这个参数设置太大，会导致“Concurrent Mode Failure”,即CMS运行期间预留的内存无法满足程序需要。此时会临时启用Serial Old收集器进行老年代的垃圾收集。
-XX:+UseCMSInitiatingOccupancyOnly:始终基于设定的阈值，不根据运行情况进行调整.如果没设置，则上面设置的CMSInitiatingOccupancyFraction在第一次会使用设定的75，之后会根据自动调整。
-XX:+DisableExplicitGC：代码手动调用System.gc()不会生效.
-XX:AutoBoxCacheMax=20000：Integer的-128--127会在创建后缓存起来，这个参数设置缓存的最大大小。
-XX:+UseGCLogFileRotation 
-XX:NumberOfGCLogFiles=10 
-XX:GCLogFileSize=10M 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-XX:+PrintHeapAtGC 
-XX:+PrintTenuringDistribution 
-XX:+PrintGCApplicationStoppedTime
-XX:-UseCounterDecay：
-XX:-TieredCompilation： 
-XX:+PrintPromotionFailure 
-XX:+HeapDumpOnOutOfMemoryError：oom时记录dump文件
```

#### String.intern()方法

java8： 当常量池不存在该字符串引用时，则将该字符创加入常量池，并返回引用。当常量池存在该字符串时，直接返回该字符串引用。

String s1 = new String("whz")；创建了几个对象： 如果常量池中存在了该字符串的引用，则只会在堆创建了一个对象。如果常量池中没有该字符串的引用，则会在堆和常量池中分别创建一个对象。

String s2 = "whz"；创建了几个对象：若常量池中存在引用，创建0个，如果不存在引用，在常量池中创建一个。

#### 线上OOM 分析

1、使用jmap 和 jstat gcutil 等命令，获得jvm的运行dump数据文件。

2、通过jmap得到的文件，看堆内存的使用率

3、通过jstat gcutil得到的文件，查看youg gc 和full gc的次数。

​		jstat -gcutil pid time:

​		s0: 新生代Survivor 0 区已使用空间百分比		s1:  新生代Survivor 1区已使用空间百分比

​		E:  新生代已使用空间百分比							    O:  老年代已使用空间百分比

​		P:  永久代已使用空间百分比  							  YGC: 程序启动到至今的youg gc次数

​		YGCT：程序启动到至今的youg gc耗时	  		FGC：程序启动到至今的full gc次数

​		FGCT: 程序启动到至今full gc耗时			   		GCT：程序启动到至今gc耗时

#### JVM OOM后，其他线程能否正常工作

OOM分很多种，有堆的OOM，栈溢出，永久代OOM。

可以正常工作的。因为当一个线程OOM后，这个线程一般会死掉，线程死掉后，其占用的内存会被释放，如果是堆OOM，则触发的gc会把内存回收，从而腾出空间给其他线程使用。

## PHP

#### CGI&FastCGI&PHP-FPM

CGI:common Gateway Interface：即应用程序于web服务器交互的一个协议。

FastCGI：即CGI的升级版，分为master进程和worker进程。master进程负责处理链接，然后分发请求给worker进程处理

PHP-FPM: FastCGI为协议规范，需要每个语言去自己实现，PHP-FPM是php的FastCGI实现。

## clickHouse



## 聚合设计点

### 重复下单

### 重复退款





